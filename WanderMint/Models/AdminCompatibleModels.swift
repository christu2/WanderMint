import Foundation
import FirebaseFirestore

// MARK: - Admin-Compatible Data Models
// These models match the structure generated by the travelAdmin dashboard

struct AdminDestinationBasedRecommendation: Identifiable, Codable {
    let id: String
    let tripOverview: String
    let destinations: [AdminDestination]
    let logistics: AdminLogistics
    let totalCost: AdminTotalCost
    let createdAt: Timestamp?
    
    enum CodingKeys: String, CodingKey {
        case id, tripOverview, destinations, logistics, totalCost, createdAt
    }
    
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        // Generate a default ID if not present
        id = try container.decodeIfPresent(String.self, forKey: .id) ?? UUID().uuidString
        tripOverview = try container.decodeIfPresent(String.self, forKey: .tripOverview) ?? ""
        destinations = try container.decodeIfPresent([AdminDestination].self, forKey: .destinations) ?? []
        logistics = try container.decodeIfPresent(AdminLogistics.self, forKey: .logistics) ?? AdminLogistics()
        totalCost = try container.decodeIfPresent(AdminTotalCost.self, forKey: .totalCost) ?? AdminTotalCost()
        createdAt = try container.decodeIfPresent(Timestamp.self, forKey: .createdAt)
    }
    
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        try container.encode(id, forKey: .id)
        try container.encode(tripOverview, forKey: .tripOverview)
        try container.encode(destinations, forKey: .destinations)
        try container.encode(logistics, forKey: .logistics)
        try container.encode(totalCost, forKey: .totalCost)
        try container.encode(createdAt, forKey: .createdAt)
    }
}

struct AdminDestination: Identifiable, Codable {
    let id: String
    let cityName: String
    let arrivalDate: String
    let departureDate: String
    let numberOfNights: Int
    let accommodationOptions: [AdminAccommodationOption]
    let recommendedActivities: [AdminActivity]
    let recommendedRestaurants: [AdminRestaurant]
    let selectedAccommodationId: String?
    
    enum CodingKeys: String, CodingKey {
        case id, cityName, arrivalDate, departureDate, numberOfNights
        case accommodationOptions, recommendedActivities, recommendedRestaurants
        case selectedAccommodationId
    }
    
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        id = try container.decode(String.self, forKey: .id)
        cityName = try container.decodeIfPresent(String.self, forKey: .cityName) ?? ""
        arrivalDate = try container.decodeIfPresent(String.self, forKey: .arrivalDate) ?? ""
        departureDate = try container.decodeIfPresent(String.self, forKey: .departureDate) ?? ""
        numberOfNights = try container.decodeIfPresent(Int.self, forKey: .numberOfNights) ?? 1
        accommodationOptions = try container.decodeIfPresent([AdminAccommodationOption].self, forKey: .accommodationOptions) ?? []
        recommendedActivities = try container.decodeIfPresent([AdminActivity].self, forKey: .recommendedActivities) ?? []
        recommendedRestaurants = try container.decodeIfPresent([AdminRestaurant].self, forKey: .recommendedRestaurants) ?? []
        selectedAccommodationId = try container.decodeIfPresent(String.self, forKey: .selectedAccommodationId)
    }
    
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        try container.encode(id, forKey: .id)
        try container.encode(cityName, forKey: .cityName)
        try container.encode(arrivalDate, forKey: .arrivalDate)
        try container.encode(departureDate, forKey: .departureDate)
        try container.encode(numberOfNights, forKey: .numberOfNights)
        try container.encode(accommodationOptions, forKey: .accommodationOptions)
        try container.encode(recommendedActivities, forKey: .recommendedActivities)
        try container.encode(recommendedRestaurants, forKey: .recommendedRestaurants)
        try container.encode(selectedAccommodationId, forKey: .selectedAccommodationId)
    }
}

struct AdminAccommodationOption: Identifiable, Codable {
    let id: String
    let priority: Int
    let hotel: AdminHotel
    
    enum CodingKeys: String, CodingKey {
        case id, priority, hotel
    }
}

struct AdminHotel: Codable {
    let name: String
    let rating: Double
    let pricePerNight: Double
    let pointsPerNight: Int?
    let loyaltyProgram: String?
    let location: String
    let bookingUrl: String
    let detailedDescription: String
    let tripadvisorId: String?
    
    enum CodingKeys: String, CodingKey {
        case name, rating, pricePerNight, pointsPerNight, loyaltyProgram
        case location, bookingUrl, detailedDescription, tripadvisorId
    }
    
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        name = try container.decode(String.self, forKey: .name)
        location = try container.decode(String.self, forKey: .location)
        bookingUrl = try container.decodeIfPresent(String.self, forKey: .bookingUrl) ?? ""
        detailedDescription = try container.decodeIfPresent(String.self, forKey: .detailedDescription) ?? ""
        tripadvisorId = try container.decodeIfPresent(String.self, forKey: .tripadvisorId)
        pointsPerNight = try container.decodeIfPresent(Int.self, forKey: .pointsPerNight)
        loyaltyProgram = try container.decodeIfPresent(String.self, forKey: .loyaltyProgram)
        
        // Safe decode for Double values to prevent NaN
        let rawRating = try container.decodeIfPresent(Double.self, forKey: .rating) ?? 4.0
        rating = rawRating.isNaN || rawRating.isInfinite ? 4.0 : rawRating
        
        let rawPrice = try container.decodeIfPresent(Double.self, forKey: .pricePerNight) ?? 0.0
        pricePerNight = rawPrice.isNaN || rawPrice.isInfinite ? 0.0 : rawPrice
    }
    
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        try container.encode(name, forKey: .name)
        try container.encode(rating, forKey: .rating)
        try container.encode(pricePerNight, forKey: .pricePerNight)
        try container.encode(pointsPerNight, forKey: .pointsPerNight)
        try container.encode(loyaltyProgram, forKey: .loyaltyProgram)
        try container.encode(location, forKey: .location)
        try container.encode(bookingUrl, forKey: .bookingUrl)
        try container.encode(detailedDescription, forKey: .detailedDescription)
        try container.encode(tripadvisorId, forKey: .tripadvisorId)
    }
}

struct AdminActivity: Identifiable, Codable {
    let id: String
    let name: String
    let description: String
    let location: String
    let estimatedCost: Double
    let estimatedDuration: String
    let category: String
    
    enum CodingKeys: String, CodingKey {
        case id, name, description, location, estimatedCost, estimatedDuration, category
    }
    
    private enum LocationKeys: String, CodingKey {
        case name, address, coordinates, nearbyLandmarks
    }
    
    private enum CostKeys: String, CodingKey {
        case cashAmount, totalCashValue, pointsAmount, pointsProgram, paymentType, notes
    }
    
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        id = try container.decode(String.self, forKey: .id)
        name = try container.decodeIfPresent(String.self, forKey: .name) ?? ""
        description = try container.decodeIfPresent(String.self, forKey: .description) ?? ""
        estimatedDuration = try container.decodeIfPresent(String.self, forKey: .estimatedDuration) ?? ""
        category = try container.decodeIfPresent(String.self, forKey: .category) ?? ""
        
        // Handle location - could be String or complex object from travelAdmin
        if let locationString = try? container.decodeIfPresent(String.self, forKey: .location) {
            location = locationString
        } else {
            // Try to decode as a complex location object
            do {
                let locationContainer = try container.nestedContainer(keyedBy: LocationKeys.self, forKey: .location)
                if let name = try? locationContainer.decodeIfPresent(String.self, forKey: .name), !name.isEmpty {
                    location = name
                } else if let address = try? locationContainer.decodeIfPresent(String.self, forKey: .address), !address.isEmpty {
                    location = address
                } else {
                    location = ""
                }
            } catch {
                location = ""
            }
        }
        
        // Handle estimatedCost - could be Double or complex cost object from travelAdmin
        if let costDouble = try? container.decodeIfPresent(Double.self, forKey: .estimatedCost) {
            // Simple Double format (legacy or simple input)
            estimatedCost = costDouble.isNaN || costDouble.isInfinite ? 0.0 : costDouble
        } else {
            // Try to decode as a complex cost object
            do {
                let costContainer = try container.nestedContainer(keyedBy: CostKeys.self, forKey: .estimatedCost)
                
                // Extract the cash amount from the complex cost object
                let cashAmount = try? costContainer.decodeIfPresent(Double.self, forKey: .cashAmount) ?? 0.0
                let totalCashValue = try? costContainer.decodeIfPresent(Double.self, forKey: .totalCashValue) ?? 0.0
                
                // Use the larger of cashAmount or totalCashValue
                let rawCost = max(cashAmount ?? 0.0, totalCashValue ?? 0.0)
                estimatedCost = rawCost.isNaN || rawCost.isInfinite ? 0.0 : rawCost
            } catch {
                // If all parsing fails, default to 0
                estimatedCost = 0.0
            }
        }
    }
    
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        try container.encode(id, forKey: .id)
        try container.encode(name, forKey: .name)
        try container.encode(description, forKey: .description)
        try container.encode(location, forKey: .location)
        try container.encode(estimatedCost, forKey: .estimatedCost)
        try container.encode(estimatedDuration, forKey: .estimatedDuration)
        try container.encode(category, forKey: .category)
    }
}

struct AdminRestaurant: Identifiable, Codable {
    let id: String
    let name: String
    let cuisine: String
    let location: String
    let priceRange: String
    let description: String
    
    enum CodingKeys: String, CodingKey {
        case id, name, cuisine, location, priceRange, description
    }
    
    private enum LocationKeys: String, CodingKey {
        case name, address, coordinates, nearbyLandmarks
    }
    
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        id = try container.decode(String.self, forKey: .id)
        name = try container.decodeIfPresent(String.self, forKey: .name) ?? ""
        cuisine = try container.decodeIfPresent(String.self, forKey: .cuisine) ?? ""
        priceRange = try container.decodeIfPresent(String.self, forKey: .priceRange) ?? ""
        description = try container.decodeIfPresent(String.self, forKey: .description) ?? ""
        
        // Handle location - could be String or complex object from travelAdmin
        if let locationString = try? container.decodeIfPresent(String.self, forKey: .location) {
            location = locationString
        } else {
            // Try to decode as a complex location object
            do {
                let locationContainer = try container.nestedContainer(keyedBy: LocationKeys.self, forKey: .location)
                if let name = try? locationContainer.decodeIfPresent(String.self, forKey: .name), !name.isEmpty {
                    location = name
                } else if let address = try? locationContainer.decodeIfPresent(String.self, forKey: .address), !address.isEmpty {
                    location = address
                } else {
                    location = ""
                }
            } catch {
                location = ""
            }
        }
    }
    
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        try container.encode(id, forKey: .id)
        try container.encode(name, forKey: .name)
        try container.encode(cuisine, forKey: .cuisine)
        try container.encode(location, forKey: .location)
        try container.encode(priceRange, forKey: .priceRange)
        try container.encode(description, forKey: .description)
    }
}

struct AdminLogistics: Codable {
    let transportSegments: [AdminTransportSegment]
    let bookingDeadlines: [AdminBookingDeadline]
    let generalInstructions: String
    
    enum CodingKeys: String, CodingKey {
        case transportSegments, bookingDeadlines, generalInstructions
    }
    
    init() {
        transportSegments = []
        bookingDeadlines = []
        generalInstructions = ""
    }
    
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        transportSegments = try container.decodeIfPresent([AdminTransportSegment].self, forKey: .transportSegments) ?? []
        bookingDeadlines = try container.decodeIfPresent([AdminBookingDeadline].self, forKey: .bookingDeadlines) ?? []
        generalInstructions = try container.decodeIfPresent(String.self, forKey: .generalInstructions) ?? ""
    }
    
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        try container.encode(transportSegments, forKey: .transportSegments)
        try container.encode(bookingDeadlines, forKey: .bookingDeadlines)
        try container.encode(generalInstructions, forKey: .generalInstructions)
    }
}

struct AdminTransportSegment: Identifiable, Codable {
    let id: String
    let fromCity: String
    let toCity: String
    let departureDate: String // Segment-level departure date
    let transportOptions: [AdminTransportOption]
    let selectedOptionId: String?
    let segmentType: String? // "outbound", "inbound", "domestic", "connecting"
    let bookingGroupId: String? // For round-trip bookings that should be booked together
    let displaySequence: Int? // For proper ordering in sequential view
    
    // Computed property for display
    var route: String {
        return "\(fromCity) → \(toCity)"
    }
    
    // Backward compatibility
    var date: String {
        return departureDate
    }
    
    enum CodingKeys: String, CodingKey {
        case id, fromCity, toCity, departureDate, transportOptions, selectedOptionId
        case segmentType, bookingGroupId, displaySequence
        // Legacy fields for backward compatibility
        case route, date
    }
    
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        id = try container.decode(String.self, forKey: .id)
        
        // Try new structure first, fall back to legacy
        if let fromCity = try container.decodeIfPresent(String.self, forKey: .fromCity),
           let toCity = try container.decodeIfPresent(String.self, forKey: .toCity) {
            self.fromCity = fromCity
            self.toCity = toCity
        } else if let route = try container.decodeIfPresent(String.self, forKey: .route) {
            // Parse legacy route format "City A → City B"
            let components = route.components(separatedBy: " → ")
            self.fromCity = components.first ?? route
            self.toCity = components.count > 1 ? components[1] : ""
        } else {
            self.fromCity = ""
            self.toCity = ""
        }
        
        // Try new date field first, fall back to legacy
        if let newDate = try container.decodeIfPresent(String.self, forKey: .departureDate) {
            departureDate = newDate
        } else if let legacyDate = try container.decodeIfPresent(String.self, forKey: .date) {
            departureDate = legacyDate
        } else {
            departureDate = ""
        }
        
        transportOptions = try container.decodeIfPresent([AdminTransportOption].self, forKey: .transportOptions) ?? []
        selectedOptionId = try container.decodeIfPresent(String.self, forKey: .selectedOptionId)
        segmentType = try container.decodeIfPresent(String.self, forKey: .segmentType)
        bookingGroupId = try container.decodeIfPresent(String.self, forKey: .bookingGroupId)
        displaySequence = try container.decodeIfPresent(Int.self, forKey: .displaySequence)
    }
    
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        try container.encode(id, forKey: .id)
        try container.encode(fromCity, forKey: .fromCity)
        try container.encode(toCity, forKey: .toCity)
        try container.encode(departureDate, forKey: .departureDate)
        try container.encode(transportOptions, forKey: .transportOptions)
        try container.encode(selectedOptionId, forKey: .selectedOptionId)
        try container.encode(segmentType, forKey: .segmentType)
        try container.encode(bookingGroupId, forKey: .bookingGroupId)
        try container.encode(displaySequence, forKey: .displaySequence)
        
        // Also encode legacy fields for backward compatibility
        try container.encode(route, forKey: .route)
        try container.encode(date, forKey: .date)
    }
}

struct AdminTransportOption: Identifiable, Codable {
    let id: String
    let transportType: String
    let priority: Int
    let cost: AdminTransportCost
    let details: AdminFlightDetails
    let duration: String
    let bookingUrl: String
    let notes: String
    let isRoundTrip: Bool? // True if this is a round-trip booking
    let linkedSegmentId: String? // ID of the linked return segment for round-trip bookings
    let recommendedSelection: Bool? // True if this is the recommended option
    
    enum CodingKeys: String, CodingKey {
        case id, transportType, priority, cost, details, duration, bookingUrl, notes
        case isRoundTrip, linkedSegmentId, recommendedSelection
    }
    
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        id = try container.decode(String.self, forKey: .id)
        transportType = try container.decodeIfPresent(String.self, forKey: .transportType) ?? "flight"
        priority = try container.decodeIfPresent(Int.self, forKey: .priority) ?? 1
        cost = try container.decodeIfPresent(AdminTransportCost.self, forKey: .cost) ?? AdminTransportCost()
        details = try container.decodeIfPresent(AdminFlightDetails.self, forKey: .details) ?? AdminFlightDetails()
        duration = try container.decodeIfPresent(String.self, forKey: .duration) ?? ""
        bookingUrl = try container.decodeIfPresent(String.self, forKey: .bookingUrl) ?? ""
        notes = try container.decodeIfPresent(String.self, forKey: .notes) ?? ""
        // Handle isRoundTrip - could be Bool or Int (0/1) from admin dashboard
        do {
            isRoundTrip = try container.decodeIfPresent(Bool.self, forKey: .isRoundTrip)
        } catch {
            // If Bool decoding fails, try as Int
            if let intValue = try? container.decodeIfPresent(Int.self, forKey: .isRoundTrip) {
                isRoundTrip = intValue == 1
            } else {
                isRoundTrip = nil
            }
        }
        
        linkedSegmentId = try container.decodeIfPresent(String.self, forKey: .linkedSegmentId)
        
        // Handle recommendedSelection - could be Bool or Int (0/1) from admin dashboard
        do {
            recommendedSelection = try container.decodeIfPresent(Bool.self, forKey: .recommendedSelection)
        } catch {
            // If Bool decoding fails, try as Int
            if let intValue = try? container.decodeIfPresent(Int.self, forKey: .recommendedSelection) {
                recommendedSelection = intValue == 1
            } else {
                recommendedSelection = nil
            }
        }
    }
    
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        try container.encode(id, forKey: .id)
        try container.encode(transportType, forKey: .transportType)
        try container.encode(priority, forKey: .priority)
        try container.encode(cost, forKey: .cost)
        try container.encode(details, forKey: .details)
        try container.encode(duration, forKey: .duration)
        try container.encode(bookingUrl, forKey: .bookingUrl)
        try container.encode(notes, forKey: .notes)
        try container.encode(isRoundTrip, forKey: .isRoundTrip)
        try container.encode(linkedSegmentId, forKey: .linkedSegmentId)
        try container.encode(recommendedSelection, forKey: .recommendedSelection)
    }
}

struct AdminTransportCost: Codable {
    let paymentType: String
    let cashAmount: Double
    let totalCashValue: Double
    let pointsAmount: Int?
    let pointsProgram: String?
    
    // Computed property to determine actual payment type based on amounts
    var effectivePaymentType: String {
        let hasPoints = (pointsAmount ?? 0) > 0
        let hasCash = cashAmount > 0 || totalCashValue > 0
        
        if hasPoints && hasCash {
            return "mixed"
        } else if hasPoints {
            return "points"
        } else {
            return "cash"
        }
    }
    
    // Computed property for display text
    var displayPaymentType: String {
        switch effectivePaymentType {
        case "points":
            return "Points"
        case "mixed":
            return "Cash + Points"
        default:
            return "Cash"
        }
    }
    
    enum CodingKeys: String, CodingKey {
        case paymentType, cashAmount, totalCashValue, pointsAmount, pointsProgram
    }
    
    init() {
        paymentType = "cash"
        cashAmount = 0.0
        totalCashValue = 0.0
        pointsAmount = nil
        pointsProgram = nil
    }
    
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        paymentType = try container.decodeIfPresent(String.self, forKey: .paymentType) ?? "cash"
        pointsAmount = try container.decodeIfPresent(Int.self, forKey: .pointsAmount)
        pointsProgram = try container.decodeIfPresent(String.self, forKey: .pointsProgram)
        
        // Safe decode for Double values to prevent NaN
        let rawCash = try container.decodeIfPresent(Double.self, forKey: .cashAmount) ?? 0.0
        cashAmount = rawCash.isNaN || rawCash.isInfinite ? 0.0 : rawCash
        
        let rawTotal = try container.decodeIfPresent(Double.self, forKey: .totalCashValue) ?? 0.0
        totalCashValue = rawTotal.isNaN || rawTotal.isInfinite ? 0.0 : rawTotal
    }
    
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        try container.encode(paymentType, forKey: .paymentType)
        try container.encode(cashAmount, forKey: .cashAmount)
        try container.encode(totalCashValue, forKey: .totalCashValue)
        try container.encode(pointsAmount, forKey: .pointsAmount)
        try container.encode(pointsProgram, forKey: .pointsProgram)
    }
}

struct AdminFlightDetails: Codable {
    let flightNumber: String
    let airline: String
    let departureAirportName: String
    let arrivalAirportName: String
    let flightClass: String
    let aircraft: String
    let details: AdminFlightSegmentDetails
    
    enum CodingKeys: String, CodingKey {
        case flightNumber, airline, departureAirportName, arrivalAirportName
        case flightClass = "class", aircraft, details
    }
    
    init() {
        flightNumber = ""
        airline = ""
        departureAirportName = ""
        arrivalAirportName = ""
        flightClass = "Economy"
        aircraft = ""
        details = AdminFlightSegmentDetails()
    }
    
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        flightNumber = try container.decodeIfPresent(String.self, forKey: .flightNumber) ?? ""
        airline = try container.decodeIfPresent(String.self, forKey: .airline) ?? ""
        departureAirportName = try container.decodeIfPresent(String.self, forKey: .departureAirportName) ?? ""
        arrivalAirportName = try container.decodeIfPresent(String.self, forKey: .arrivalAirportName) ?? ""
        flightClass = try container.decodeIfPresent(String.self, forKey: .flightClass) ?? "Economy"
        aircraft = try container.decodeIfPresent(String.self, forKey: .aircraft) ?? ""
        
        // Handle nested details structure from database
        if let detailsData = try? container.decode(AdminFlightSegmentDetails.self, forKey: .details) {
            details = detailsData
        } else {
            // Create default details with available data
            details = AdminFlightSegmentDetails()
        }
        
    }
    
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        try container.encode(flightNumber, forKey: .flightNumber)
        try container.encode(airline, forKey: .airline)
        try container.encode(departureAirportName, forKey: .departureAirportName)
        try container.encode(arrivalAirportName, forKey: .arrivalAirportName)
        try container.encode(flightClass, forKey: .flightClass)
        try container.encode(aircraft, forKey: .aircraft)
        try container.encode(details, forKey: .details)
    }
}

struct AdminFlightSegmentDetails: Codable {
    let departure: AdminFlightSegment
    let arrival: AdminFlightSegment
    let route: String
    let showDateChange: Bool
    
    enum CodingKeys: String, CodingKey {
        case departure, arrival, route, showDateChange
    }
    
    init() {
        departure = AdminFlightSegment()
        arrival = AdminFlightSegment()
        route = ""
        showDateChange = false
    }
    
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        // Handle the case where departure/arrival might only have airportCode
        if let departureData = try? container.decode(AdminFlightSegment.self, forKey: .departure) {
            departure = departureData
        } else {
            departure = AdminFlightSegment()
        }
        
        if let arrivalData = try? container.decode(AdminFlightSegment.self, forKey: .arrival) {
            arrival = arrivalData
        } else {
            arrival = AdminFlightSegment()
        }
        
        route = try container.decodeIfPresent(String.self, forKey: .route) ?? ""
        showDateChange = try container.decodeIfPresent(Bool.self, forKey: .showDateChange) ?? false
    }
    
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        try container.encode(departure, forKey: .departure)
        try container.encode(arrival, forKey: .arrival)
        try container.encode(route, forKey: .route)
        try container.encode(showDateChange, forKey: .showDateChange)
    }
}

struct AdminFlightSegment: Codable {
    let airportCode: String
    let time: String
    let date: String
    
    enum CodingKeys: String, CodingKey {
        case airportCode, time, date
    }
    
    init() {
        airportCode = ""
        time = ""
        date = ""
    }
    
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        airportCode = try container.decodeIfPresent(String.self, forKey: .airportCode) ?? ""
        time = try container.decodeIfPresent(String.self, forKey: .time) ?? ""
        date = try container.decodeIfPresent(String.self, forKey: .date) ?? ""
        
    }
    
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        try container.encode(airportCode, forKey: .airportCode)
        try container.encode(time, forKey: .time)
        try container.encode(date, forKey: .date)
    }
}

struct AdminBookingDeadline: Identifiable, Codable {
    let id: String
    let item: String
    let deadline: String
    let priority: String
    
    enum CodingKeys: String, CodingKey {
        case id, item, deadline, priority
    }
}

struct AdminTotalCost: Codable {
    let totalEstimate: Double
    let flights: Double
    let accommodation: Double
    let activities: Double
    let food: Double
    let localTransport: Double
    let miscellaneous: Double
    let currency: String
    
    enum CodingKeys: String, CodingKey {
        case totalEstimate, flights, accommodation, activities, food
        case localTransport, miscellaneous, currency
    }
    
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        currency = try container.decodeIfPresent(String.self, forKey: .currency) ?? "USD"
        
        // Safe decode for all Double cost values to prevent NaN
        let rawTotal = try container.decodeIfPresent(Double.self, forKey: .totalEstimate) ?? 0.0
        totalEstimate = rawTotal.isNaN || rawTotal.isInfinite ? 0.0 : rawTotal
        
        let rawFlights = try container.decodeIfPresent(Double.self, forKey: .flights) ?? 0.0
        flights = rawFlights.isNaN || rawFlights.isInfinite ? 0.0 : rawFlights
        
        let rawAccommodation = try container.decodeIfPresent(Double.self, forKey: .accommodation) ?? 0.0
        accommodation = rawAccommodation.isNaN || rawAccommodation.isInfinite ? 0.0 : rawAccommodation
        
        let rawActivities = try container.decodeIfPresent(Double.self, forKey: .activities) ?? 0.0
        activities = rawActivities.isNaN || rawActivities.isInfinite ? 0.0 : rawActivities
        
        let rawFood = try container.decodeIfPresent(Double.self, forKey: .food) ?? 0.0
        food = rawFood.isNaN || rawFood.isInfinite ? 0.0 : rawFood
        
        let rawTransport = try container.decodeIfPresent(Double.self, forKey: .localTransport) ?? 0.0
        localTransport = rawTransport.isNaN || rawTransport.isInfinite ? 0.0 : rawTransport
        
        let rawMisc = try container.decodeIfPresent(Double.self, forKey: .miscellaneous) ?? 0.0
        miscellaneous = rawMisc.isNaN || rawMisc.isInfinite ? 0.0 : rawMisc
    }
    
    init() {
        totalEstimate = 0.0
        flights = 0.0
        accommodation = 0.0
        activities = 0.0
        food = 0.0
        localTransport = 0.0
        miscellaneous = 0.0
        currency = "USD"
    }
    
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        try container.encode(totalEstimate, forKey: .totalEstimate)
        try container.encode(flights, forKey: .flights)
        try container.encode(accommodation, forKey: .accommodation)
        try container.encode(activities, forKey: .activities)
        try container.encode(food, forKey: .food)
        try container.encode(localTransport, forKey: .localTransport)
        try container.encode(miscellaneous, forKey: .miscellaneous)
        try container.encode(currency, forKey: .currency)
    }
}